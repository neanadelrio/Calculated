var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OxyDialog", ()=>OxyDialog
);
var _lit = require("lit");
var _decorators = require("lit/decorators");
function _decorate(decorators, factory, superClass, mixins) {
    var api = _getDecoratorsApi();
    if (mixins) for(var i = 0; i < mixins.length; i++)api = mixins[i](api);
    var r = factory(function initialize(O) {
        api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);
    api.initializeClassElements(r.F, decorated.elements);
    return api.runClassFinishers(r.F, decorated.finishers);
}
function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
        return api;
    };
    var api = {
        elementsDefinitionOrder: [
            [
                "method"
            ],
            [
                "field"
            ]
        ],
        initializeInstanceElements: function(O, elements) {
            [
                "method",
                "field"
            ].forEach(function(kind) {
                elements.forEach(function(element) {
                    if (element.kind === kind && element.placement === "own") this.defineClassElement(O, element);
                }, this);
            }, this);
        },
        initializeClassElements: function(F, elements) {
            var proto = F.prototype;
            [
                "method",
                "field"
            ].forEach(function(kind) {
                elements.forEach(function(element) {
                    var placement = element.placement;
                    if (element.kind === kind && (placement === "static" || placement === "prototype")) {
                        var receiver = placement === "static" ? F : proto;
                        this.defineClassElement(receiver, element);
                    }
                }, this);
            }, this);
        },
        defineClassElement: function(receiver, element) {
            var descriptor = element.descriptor;
            if (element.kind === "field") {
                var initializer = element.initializer;
                descriptor = {
                    enumerable: descriptor.enumerable,
                    writable: descriptor.writable,
                    configurable: descriptor.configurable,
                    value: initializer === void 0 ? void 0 : initializer.call(receiver)
                };
            }
            Object.defineProperty(receiver, element.key, descriptor);
        },
        decorateClass: function(elements, decorators) {
            var newElements = [];
            var finishers = [];
            var placements = {
                static: [],
                prototype: [],
                own: []
            };
            elements.forEach(function(element) {
                this.addElementPlacement(element, placements);
            }, this);
            elements.forEach(function(element) {
                if (!_hasDecorators(element)) return newElements.push(element);
                var elementFinishersExtras = this.decorateElement(element, placements);
                newElements.push(elementFinishersExtras.element);
                newElements.push.apply(newElements, elementFinishersExtras.extras);
                finishers.push.apply(finishers, elementFinishersExtras.finishers);
            }, this);
            if (!decorators) return {
                elements: newElements,
                finishers: finishers
            };
            var result = this.decorateConstructor(newElements, decorators);
            finishers.push.apply(finishers, result.finishers);
            result.finishers = finishers;
            return result;
        },
        addElementPlacement: function(element, placements, silent) {
            var keys = placements[element.placement];
            if (!silent && keys.indexOf(element.key) !== -1) throw new TypeError("Duplicated element (" + element.key + ")");
            keys.push(element.key);
        },
        decorateElement: function(element, placements) {
            var extras = [];
            var finishers = [];
            for(var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--){
                var keys = placements[element.placement];
                keys.splice(keys.indexOf(element.key), 1);
                var elementObject = this.fromElementDescriptor(element);
                var elementFinisherExtras = this.toElementFinisherExtras(decorators[i](elementObject) || elementObject);
                element = elementFinisherExtras.element;
                this.addElementPlacement(element, placements);
                if (elementFinisherExtras.finisher) finishers.push(elementFinisherExtras.finisher);
                var newExtras = elementFinisherExtras.extras;
                if (newExtras) {
                    for(var j = 0; j < newExtras.length; j++)this.addElementPlacement(newExtras[j], placements);
                    extras.push.apply(extras, newExtras);
                }
            }
            return {
                element: element,
                finishers: finishers,
                extras: extras
            };
        },
        decorateConstructor: function(elements, decorators) {
            var finishers = [];
            for(var i = decorators.length - 1; i >= 0; i--){
                var obj = this.fromClassDescriptor(elements);
                var elementsAndFinisher = this.toClassDescriptor(decorators[i](obj) || obj);
                if (elementsAndFinisher.finisher !== undefined) finishers.push(elementsAndFinisher.finisher);
                if (elementsAndFinisher.elements !== undefined) {
                    elements = elementsAndFinisher.elements;
                    for(var j = 0; j < elements.length - 1; j++)for(var k = j + 1; k < elements.length; k++){
                        if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) throw new TypeError("Duplicated element (" + elements[j].key + ")");
                    }
                }
            }
            return {
                elements: elements,
                finishers: finishers
            };
        },
        fromElementDescriptor: function(element) {
            var obj = {
                kind: element.kind,
                key: element.key,
                placement: element.placement,
                descriptor: element.descriptor
            };
            var desc = {
                value: "Descriptor",
                configurable: true
            };
            Object.defineProperty(obj, Symbol.toStringTag, desc);
            if (element.kind === "field") obj.initializer = element.initializer;
            return obj;
        },
        toElementDescriptors: function(elementObjects) {
            if (elementObjects === undefined) return;
            return _toArray(elementObjects).map(function(elementObject) {
                var element = this.toElementDescriptor(elementObject);
                this.disallowProperty(elementObject, "finisher", "An element descriptor");
                this.disallowProperty(elementObject, "extras", "An element descriptor");
                return element;
            }, this);
        },
        toElementDescriptor: function(elementObject) {
            var kind = String(elementObject.kind);
            if (kind !== "method" && kind !== "field") throw new TypeError("An element descriptor's .kind property must be either \"method\" or \"field\", but a decorator created an element descriptor with .kind \"" + kind + '"');
            var key = _toPropertyKey(elementObject.key);
            var placement = String(elementObject.placement);
            if (placement !== "static" && placement !== "prototype" && placement !== "own") throw new TypeError("An element descriptor's .placement property must be one of \"static\", \"prototype\" or \"own\", but a decorator created an element descriptor with .placement \"" + placement + '"');
            var descriptor = elementObject.descriptor;
            this.disallowProperty(elementObject, "elements", "An element descriptor");
            var element = {
                kind: kind,
                key: key,
                placement: placement,
                descriptor: Object.assign({
                }, descriptor)
            };
            if (kind !== "field") this.disallowProperty(elementObject, "initializer", "A method descriptor");
            else {
                this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor");
                this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor");
                this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor");
                element.initializer = elementObject.initializer;
            }
            return element;
        },
        toElementFinisherExtras: function(elementObject) {
            var element = this.toElementDescriptor(elementObject);
            var finisher = _optionalCallableProperty(elementObject, "finisher");
            var extras = this.toElementDescriptors(elementObject.extras);
            return {
                element: element,
                finisher: finisher,
                extras: extras
            };
        },
        fromClassDescriptor: function(elements) {
            var obj = {
                kind: "class",
                elements: elements.map(this.fromElementDescriptor, this)
            };
            var desc = {
                value: "Descriptor",
                configurable: true
            };
            Object.defineProperty(obj, Symbol.toStringTag, desc);
            return obj;
        },
        toClassDescriptor: function(obj) {
            var kind = String(obj.kind);
            if (kind !== "class") throw new TypeError("A class descriptor's .kind property must be \"class\", but a decorator created a class descriptor with .kind \"" + kind + '"');
            this.disallowProperty(obj, "key", "A class descriptor");
            this.disallowProperty(obj, "placement", "A class descriptor");
            this.disallowProperty(obj, "descriptor", "A class descriptor");
            this.disallowProperty(obj, "initializer", "A class descriptor");
            this.disallowProperty(obj, "extras", "A class descriptor");
            var finisher = _optionalCallableProperty(obj, "finisher");
            var elements = this.toElementDescriptors(obj.elements);
            return {
                elements: elements,
                finisher: finisher
            };
        },
        runClassFinishers: function(constructor, finishers) {
            for(var i = 0; i < finishers.length; i++){
                var newConstructor = finishers[i](constructor);
                if (newConstructor !== undefined) {
                    if (typeof newConstructor !== "function") throw new TypeError("Finishers must return a constructor.");
                    constructor = newConstructor;
                }
            }
            return constructor;
        },
        disallowProperty: function(obj, name, objectType) {
            if (obj[name] !== undefined) throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
    };
    return api;
}
function _createElementDescriptor(def) {
    var key = _toPropertyKey(def.key);
    var descriptor;
    if (def.kind === "method") descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false
    };
    else if (def.kind === "get") descriptor = {
        get: def.value,
        configurable: true,
        enumerable: false
    };
    else if (def.kind === "set") descriptor = {
        set: def.value,
        configurable: true,
        enumerable: false
    };
    else if (def.kind === "field") descriptor = {
        configurable: true,
        writable: true,
        enumerable: true
    };
    var element = {
        kind: def.kind === "field" ? "field" : "method",
        key: key,
        placement: def.static ? "static" : def.kind === "field" ? "own" : "prototype",
        descriptor: descriptor
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;
    return element;
}
function _coalesceGetterSetter(element, other) {
    if (element.descriptor.get !== undefined) other.descriptor.get = element.descriptor.get;
    else other.descriptor.set = element.descriptor.set;
}
function _coalesceClassElements(elements) {
    var newElements = [];
    var isSameElement = function(other) {
        return other.kind === "method" && other.key === element.key && other.placement === element.placement;
    };
    for(var i = 0; i < elements.length; i++){
        var element = elements[i];
        var other;
        if (element.kind === "method" && (other = newElements.find(isSameElement))) {
            if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
                if (_hasDecorators(element) || _hasDecorators(other)) throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated.");
                other.descriptor = element.descriptor;
            } else {
                if (_hasDecorators(element)) {
                    if (_hasDecorators(other)) throw new ReferenceError("Decorators can't be placed on different accessors with for the same property (" + element.key + ").");
                    other.decorators = element.decorators;
                }
                _coalesceGetterSetter(element, other);
            }
        } else newElements.push(element);
    }
    return newElements;
}
function _hasDecorators(element) {
    return element.decorators && element.decorators.length;
}
function _isDataDescriptor(desc) {
    return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);
}
function _optionalCallableProperty(obj, name) {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") throw new TypeError("Expected '" + name + "' to be a function");
    return value;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
let OxyDialog = _decorate([
    _decorators.customElement('oxy-dialog')
], function(_initialize, _LitElement) {
    class OxyDialog1 extends _LitElement {
        constructor(...args){
            super(...args);
            _initialize(this);
        }
    }
    return {
        F: OxyDialog1,
        d: [
            {
                kind: "get",
                static: true,
                key: "styles",
                value: function styles() {
                    return _lit.css`\n      :host {\n        display: none;\n      }\n      :host([opened]) {\n        display: block;\n      }\n      #backdrop {\n        position: fixed;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        background: var(--oxy-dialog-backdrop-background, rgba(0, 0, 0, 0.3));\n        z-index: 10;\n      }\n      #layout {\n        position: fixed;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        z-index: 11;\n        pointer-events: none;\n      }\n      #dialog {\n        background: var(--oxy-dialog-background, white);\n        color: var(--oxy-dialog-text-color, currentcolor);\n        min-width: var(--oxy-dialog-min-width, 200px);\n        max-width: var(--oxy-dialog-max-width, 500px);\n        max-height: var(--oxy-dialog-max-height, 80%);\n        flex-shrink: 0;\n        box-shadow: var(--oxy-dialog-box-shadow, 0 8px 64px rgba(0, 0, 0, 0.5));\n        border-radius: 4px;\n        pointer-events: auto;\n      }\n      h2 {\n        font-size: 1.2em;\n        line-height: 2em;\n        margin: 0;\n        padding: 16px 16px 8px 16px;\n      }\n      slot[name="buttons"] {\n        display: flex;\n        flex-direction: row;\n        justify-content: flex-end;\n        padding: 16px 8px 8px 8px;\n      }\n      [hidden] {\n        display: none !important;\n      }\n    `;
                }
            },
            {
                kind: "field",
                key: "keyListener",
                value () {
                    return this.onKeydown.bind(this);
                }
            },
            {
                kind: "field",
                key: "savedFocus",
                value: void 0
            },
            {
                kind: "field",
                decorators: [
                    _decorators.query('#backdrop')
                ],
                key: "backdropElem",
                value: void 0
            },
            {
                kind: "field",
                decorators: [
                    _decorators.query('#dialog')
                ],
                key: "dialogElem",
                value: void 0
            },
            {
                kind: "field",
                decorators: [
                    _decorators.property({
                        type: Boolean,
                        reflect: true
                    })
                ],
                key: "opened",
                value () {
                    return false;
                }
            },
            {
                kind: "field",
                decorators: [
                    _decorators.property({
                        type: String
                    })
                ],
                key: "heading",
                value () {
                    return '';
                }
            },
            {
                kind: "field",
                decorators: [
                    _decorators.property({
                        type: Boolean
                    })
                ],
                key: "backdrop",
                value () {
                    return false;
                }
            },
            {
                kind: "field",
                decorators: [
                    _decorators.property({
                        type: Boolean
                    })
                ],
                key: "noescape",
                value () {
                    return false;
                }
            },
            {
                kind: "field",
                decorators: [
                    _decorators.property({
                        type: Boolean
                    })
                ],
                key: "showBackdrop",
                value () {
                    return false;
                }
            },
            {
                kind: "method",
                key: "updated",
                value: function updated(changedProps) {
                    if (changedProps.has('opened')) {
                        if (this.opened) this.afterOpen();
                        else this.afterClose();
                    }
                }
            },
            {
                kind: "method",
                key: "render",
                value: function render() {
                    return _lit.html`\n      <div\n          id="backdrop"\n          ?hidden=${!this.showBackdrop}\n          @click=${this.onBackdropClick}>\n      </div>\n\n      <div id="layout">\n        <div id="dialog" part="dialog">\n          ${this.heading ? _lit.html`<h2>${this.heading}</h2>` : _lit.html``}\n          <slot></slot>\n          <slot name="buttons"></slot>\n        </div>\n      </div>\n    `;
                }
            },
            {
                kind: "method",
                key: "open",
                value: function open() {
                    this.opened = true;
                }
            },
            {
                kind: "method",
                key: "close",
                value: function close() {
                    this.opened = false;
                }
            },
            {
                kind: "method",
                key: "afterOpen",
                value: function afterOpen() {
                    this.showBackdrop = this.backdrop;
                    this.addKeyListener();
                    this.saveAndMoveFocus();
                    this.dispatchEvent(new CustomEvent('opened'));
                }
            },
            {
                kind: "method",
                key: "afterClose",
                value: function afterClose() {
                    this.showBackdrop = false;
                    this.removeKeyListener();
                    this.restoreFocus();
                    this.dispatchEvent(new CustomEvent('closed'));
                }
            },
            {
                kind: "method",
                key: "addKeyListener",
                value: function addKeyListener() {
                    document.body.addEventListener('keydown', this.keyListener);
                }
            },
            {
                kind: "method",
                key: "removeKeyListener",
                value: function removeKeyListener() {
                    document.body.removeEventListener('keydown', this.keyListener);
                }
            },
            {
                kind: "method",
                key: "onBackdropClick",
                value: function onBackdropClick() {
                    if (!this.noescape) this.close();
                }
            },
            {
                kind: "method",
                key: "onKeydown",
                value: function onKeydown(event) {
                    switch(event.key){
                        case 'Escape':
                            event.preventDefault();
                            this.onEscapePress();
                            break;
                        case 'Tab':
                            event.preventDefault();
                            this.onTabPress();
                            break;
                    }
                }
            },
            {
                kind: "method",
                key: "onEscapePress",
                value: function onEscapePress() {
                    if (!this.noescape) this.close();
                }
            },
            {
                kind: "method",
                key: "saveAndMoveFocus",
                value: function saveAndMoveFocus() {
                    this.savedFocus = document.activeElement;
                    while(true){
                        if (!this.savedFocus?.shadowRoot) break;
                        const activeElement = this.savedFocus.shadowRoot.activeElement;
                        if (!activeElement) break;
                        this.savedFocus = activeElement;
                    }
                    this.focus();
                }
            },
            {
                kind: "method",
                key: "restoreFocus",
                value: function restoreFocus() {
                    this.savedFocus?.focus();
                }
            },
            {
                kind: "method",
                key: "onTabPress",
                value: function onTabPress() {
                }
            }
        ]
    };
}, _lit.LitElement);
