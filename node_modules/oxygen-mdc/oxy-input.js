var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { LitElement, css, html } from 'lit';
import { customElement, property } from 'lit/decorators';
/**
 * A simple input element with various opportunities for styling. Most notably,
 * an icon can be specified which focuses the input when clicked.
 */
let OxyInput = class OxyInput extends LitElement {
    constructor() {
        super(...arguments);
        this.input = null;
        this.value = '';
        this.type = 'text';
        this.maxlength = '';
        this.placeholder = '';
        this.readonly = false;
        this.disabled = false;
        this.focused = false;
        this.selectOnFocus = false;
        this.clearOnEscape = false;
        this.autofocus = false;
    }
    static get styles() {
        return css `
      :host {
        display: flex;
        flex-direction: column;
        margin: 2px 0;
      }
      :host([disabled]) {
        opacity: 0.5;
      }
      #container {
        display: flex;
        align-items: center;
        flex-shrink: 0;
        background: var(--oxy-input-background, white);
        border: var(--oxy-input-border, 1px solid #ddd);
        border-radius: var(--oxy-input-border-radius, 2px);
        box-shadow: var(--oxy-input-box-shadow, 0 0 0 white);
        transition: all 25ms;
      }
      :host([focused]) #container {
        background: var(--oxy-input-background-focused, white);
        border: var(--oxy-input-border-focused, 1px solid #ccc);
        box-shadow: var(--oxy-input-box-shadow-focused, 0 0 0 white);
      }
      input {
        flex-grow: 1;
        color: var(--oxy-input-text-color, currentcolor);
        font: inherit;
        padding: 0;
        margin: var(--oxy-input-text-padding, 6px);
        border: none;
        box-shadow: none;
        outline: none;
        background: transparent;
        text-align: inherit;
        width: 0;
      }
      input::placeholder {
        color: var(--oxy-input-placeholder-color, gray);
      }
    `;
    }
    render() {
        return html `
      <div id="container" @click=${this.focus}>
        <slot name="before"></slot>
        <input
            id="input"
            .value=${this.value}
            ?disabled=${this.disabled}
            ?readonly=${this.readonly}
            type="${this.type}"
            maxlength="${this.maxlength}"
            placeholder="${this.placeholder}"
            spellcheck="false"
            @keydown=${this.onKeydown}
            @input=${this.onValueChanged}
            @focus=${this.onFocus}
            @blur=${this.onBlur}>
        <slot name="after"></slot>
      </div>
    `;
    }
    firstUpdated() {
        if (this.autofocus) {
            setTimeout(() => this.focus(), 0);
        }
        if (!this.shadowRoot)
            return;
        this.input = this.shadowRoot.getElementById('input');
    }
    focus() {
        if (!this.input)
            return;
        this.input.focus();
    }
    select() {
        if (!this.input)
            return;
        this.input.setSelectionRange(0, this.input.value.length);
    }
    deselect() {
        if (!this.input)
            return;
        this.input.setSelectionRange(0, 0);
    }
    clear() {
        if (this.value === '')
            return;
        this.value = '';
        this.emitChange();
    }
    copyToClipboard() {
        if (this.type === 'password') {
            this.copyPasswordToClipboard();
            return;
        }
        this.focus();
        this.select();
        document.execCommand('copy');
        this.deselect();
    }
    async copyPasswordToClipboard() {
        this.type = 'text';
        await this.updateComplete;
        this.copyToClipboard();
        this.type = 'password';
    }
    emitChange() {
        this.dispatchEvent(new CustomEvent('change', { detail: this.value }));
    }
    onValueChanged() {
        if (!this.input)
            return;
        this.value = this.input.value;
        this.emitChange();
    }
    onKeydown(event) {
        if (this.clearOnEscape && event.key === "Escape") {
            this.clear();
        }
    }
    onFocus() {
        this.focused = true;
        if (this.selectOnFocus) {
            this.select();
        }
    }
    onBlur() {
        this.focused = false;
    }
};
__decorate([
    property({ type: String })
], OxyInput.prototype, "value", void 0);
__decorate([
    property({ type: String })
], OxyInput.prototype, "type", void 0);
__decorate([
    property({ type: String })
], OxyInput.prototype, "maxlength", void 0);
__decorate([
    property({ type: String })
], OxyInput.prototype, "placeholder", void 0);
__decorate([
    property({ type: Boolean })
], OxyInput.prototype, "readonly", void 0);
__decorate([
    property({ type: Boolean })
], OxyInput.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], OxyInput.prototype, "focused", void 0);
__decorate([
    property({ type: Boolean })
], OxyInput.prototype, "selectOnFocus", void 0);
__decorate([
    property({ type: Boolean })
], OxyInput.prototype, "clearOnEscape", void 0);
__decorate([
    property({ type: Boolean })
], OxyInput.prototype, "autofocus", void 0);
OxyInput = __decorate([
    customElement('oxy-input')
], OxyInput);
export { OxyInput };
